#ifndef FORWARD_END_POINT_H
#define FORWARD_END_POINT_H

#include <limits>
#include "signal_protocol_types.h"

#ifdef __cplusplus
extern "C" {
#endif

#define FORWARD_STARTING_NONCE INT_MIN
/*
 * the messages was generated by the proxy server
 */
#define FORWARD_DIRECTION_PROXY 0
/*
 * the message was received from a remote account.
 */
#define FORWARD_DIRECTION_RECEIVE 1
/*
 * the message was sent from the user of this account.
 */
#define FORWARD_DIRECTION_SENT 2


typdef struct {
	bool account;
	bool owner;
	bool listen;
	bool pickup;
	bool interrupt;
	bool feedback;
	bool militirised;
} capabilities_t;



/*
 * Startup initialisation.
 */
void init();

typedef int _forward_deliver(int nonce, int socket_id, int session_id, int direction,
		const uint8_t *padded_message, size_t padded_message_len);

int forward_query_capabilities(int nonce, int socket_id);

/*
 * Connect to the proxy through an existing connected socket.
 */
int forward_jack_in(int nonce, int socket_id, _forward_deliver* reverse_deliver);
/*
 * disconnect from the proxy.
 */
int forward_jack_out(int nonce, int socket_id);
/*
 * register a new account with keys stored on the proxy.
 */
int forward_register_account(int nonce, int socket_id, const uint8_t *pin,
		size_t pin_len);
/*
 * take over an existing account.
 */
int forward_inject_account(int nonce, int socket_id,
		ratchet_identity_key_pair *identity_key_pair, uint32_t registration_id,
		signal_protocol_key_helper_pre_key_list_node *pre_keys_head,
		session_signed_pre_key *signed_pre_key, const uint8_t *pin,
		size_t pin_len);
/*
 * Signal a connection fault.
 */
int forward_sig_fault(int nonce, int socket_id);
/*
 * Limit expenses on a metered connection. Add a delay between messages.
 */
int forward_sig_too_much_data(int socket_id, long int latency);
/*
 * sent back information to the client about open sessions.
 */
int forward_refresh_account(int nonce, int socket_id);
/*
 * sent back information to the client about a particular session.
 */
int forward_refresh_session(int nonce, int socket_id, int session_id);
/*
 * Create a session to a recipient.
 */
int forward_initiate_session(int nonce, int socket_id, signal_protocol_address address);
/*
 * send a message to recipient over a session.
 */
int forward_deliver(int nonce, int socket_id, int session_id,
		const uint8_t *padded_message, size_t padded_message_len);
/*
 * Take control of a session and start receiving and sending messages.
 */
int forward_pickup(int nonce, int socket_id, int session_id);
/*
 * Give up control of a session.
 */
int forward_putdown(int nonce, int socket_id, int session_id);
/*
 * Perform a security reset on the session.
 */
int forward_reset(int nonce, int socket_id, int session_id);
/*
 * Listen in on a session by receiving messages with no ability to send messages to the recipient.
 */
int forward_listen(int nonce, int socket_id, int session_id);
/*
 * Stop listening in on a session.
 */
int forward_mute(int nonce, int socket_id, int session_id);

/*
 * Create an account for performing a man-in-the-middle attack
 */
int forward_mz_masquerade(int nonce, int socket_id, signal_protocol_address alice, signal_protocol_address bob);
/*
 * covert listening & logging.
 */
int forward_mz_tow_row_row(int nonce, int socket_id, int intercept_id);

#ifdef __cplusplus
}
#endif

#endif

